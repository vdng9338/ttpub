/**
 *  Copyright 2007 TriMet, released under a modified Mozilla 1.1 license.
 *  Please see http://timetablepublisher.org/downloads/list
 *  (TriMet OSS License.htm) for the full text of the license.
 */

package org.timetablepublisher.configure;

import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;

import org.timetablepublisher.utils.Constants;
import org.timetablepublisher.configure.loader.CsvColumn;
import org.timetablepublisher.schedule.ScheduleDataQuery;
import org.timetablepublisher.table.RouteDescription;
import org.timetablepublisher.table.RouteDescriptionImpl;
import org.timetablepublisher.table.TimesTable;

/**
 * The purpose of RouteNames is to (re)name the route, service key or destination.  If this
 * is a route that is generated by the Configuration itself (eg: @see ComboRoutes), then
 * a name / service key / destination combo is needed.
 *  
 * @author  Frank Purcell (purcellf@trimet.org)
 * @date    Oct 24, 2006
 * @project http://timetablepublisher.org
 * @version Revision: 1.0
 * @since   1.0
 */
@SuppressWarnings("unchecked")
public class RouteNames extends Configure
{
    @CsvColumn(index=6, name="Route Name", details="configured route name")
    public String m_routeName;
    
    @CsvColumn(index=7, name="Service Key Name", details="configured service key name")
    public String m_keyName;
    
    @CsvColumn(index=8, name="Destination", details="detination name for this route / direction / key")
    public String m_destination;

    @CsvColumn(index=9, name="Show Stop ID", details="boolean that controls whether a Stop ID is shown or not")
    public Boolean m_showStopID = true; // show by default
    
    
    public RouteNames()
    {        
    }
    
    public RouteNames(String agency, String route, String dir, String key, String lang)
    {
        setValues(agency, route, dir, key, lang);
    }
    
    public String getDestination()
    {
        return m_destination;
    }

    public String getKeyName()
    {
        return m_keyName;
    }

    public String getRouteName()
    {
        return m_routeName;
    }

    public Boolean showStopID()
    {
        return m_showStopID;
    }

    
    
    // setters
    public void setDestination(String destination)
    {
        if(destination == null) return;
        m_destination = destination.trim();
    }

    public void setKeyName(String keyName)
    {
        if(keyName == null) return;
        m_keyName = keyName.trim();
    }

    public void setRouteName(String routeName)
    {
        if(routeName == null) return;
        m_routeName = routeName.trim();
    }

    public void setShowStopID(String show)
    {
        boolean val = true;  // show the stopID by default
        
        if(show != null && show.length() > 0)
        {
            // if we see something that looks like NO, then don't show the stopID
            String tmp = show.toLowerCase();
            if(tmp.equals("f") || tmp.equals("false") || tmp.equals("no"))
            {
                val = false;
            }
        }

        m_showStopID = val;
    }
    
    
    
    
    synchronized public static List<RouteDescription> getRouteNames(TimesTable tt, ScheduleDataQuery query)
    {
        String date = Constants.dateSDF.format(new Date());
        if(tt != null) date = tt.getDate();
        
        List<RouteDescription> retVal = query.getRouteNames(date);
        if(retVal == null) 
        {
            retVal = new ArrayList<RouteDescription>();
        }

        if(query != null && okToProcess(tt, Configure.class)) 
        {
            // get unique (hence hash) set of routes we'd like to rename
            Hashtable<String,RouteNames> ht = new Hashtable<String,RouteNames>();
            List rnList = tt.getConfiguration().getData(RouteNames.class);
            if(rnList != null && rnList.size() > 0)
            {
                for(RouteNames rn : (List<RouteNames>)rnList) 
                {
                    if(rn == null || rn.getRouteID() == null || rn.getRouteID().length() < 1) continue;
                    if(rn.getRouteName() == null || rn.getRouteName().length() < 1)           continue;
                    String rnLang = rn.getLang()     == null ? "" : rn.getLang();
                    String ttLang = tt.getLanguage() == null ? "" : tt.getLanguage();
                    if(rnLang.length() > 0 && ttLang.length() > 0 && !rnLang.equals(ttLang))  continue;
                    
                    if(rn != null && rn.getRouteName() != null && rn.getRouteName().length() > 1)
                    {
                        String nm = query.getRouteIDForList(rn.getAgency(), rn.getRouteID());
                        ht.put(nm, rn);
                    }
                }
            }
            
            // loop through current routes, and rename existing routes from config
            for(RouteDescription r : retVal)
            {            
                if(r == null || r.getRouteID() == null) continue;
                RouteNames rn = ht.get(r.getRouteID());
                if(rn != null)
                {
                    r.setValues(rn);
                    ht.remove(r.getRouteID()); // remove from hash-table, so that loop below does not add it again
                }
            }
            
            for(RouteNames rn : ht.values())
            {
                if(rn == null) continue;
                String routeID = query.getRouteIDForList(rn.getAgency(), rn.getRouteID());
                RouteDescription rd = new RouteDescriptionImpl(rn, routeID);
                retVal.add(rd);
            }
        }
        
        return retVal;
    }
    
    public static RouteDescription getRouteDirectionName(TimesTable tt, ScheduleDataQuery query)
    {        
        RouteDescription   retVal = query.getRouteDirectionName(tt);
        if(retVal == null) retVal = new RouteDescriptionImpl(null, (short)0);
        if(tt == null || tt.getConfiguration() == null) return retVal;
        
        // check 1: configuration route / dir  
        RouteNames rn = (RouteNames)tt.getConfiguration().findData(new RouteNames(tt.getAgencyName(), tt.getRouteID(), tt.getDir().toString(), tt.getKey().toString(), tt.getLanguage()));
        if(!tt.bypassConfig() && rn != null)
        {
            retVal = new RouteDescriptionImpl(rn);            
        }
        
        // check 2: does title have both name, direction and key ?? 
        if(!retVal.hasRouteAndDir())
        {
            RouteDescription tmp = query.getRouteDirectionName(tt);
            if(tmp == null) 
            {
                tmp = new RouteDescriptionImpl("totally", "not", "sure", "what", "happened", true);                
            }            
            retVal.append(tmp);
        }       
        if(!retVal.isComplete())
        {
            retVal.setServiceKeyName(tt.getKey().toString());                
        }

        return retVal;        
    }
    
    public static RouteDescription setRouteDirectionName(TimesTable tt, ScheduleDataQuery query)
    {
        RouteDescription retVal = getRouteDirectionName(tt, query);
        
        // assignment
        tt.setRouteName(retVal.getRouteName());
        tt.setDestination(retVal.getDestination());
        tt.setKeyName(retVal.getServiceKeyName());
        tt.setShowStopIDs(retVal.showStopIDs());
        
        return retVal;
    }
}    
